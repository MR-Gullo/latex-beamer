\documentclass{beamer}
% Use DS9 global theme
\usepackage{../../../../shared/templates/ds9_theme}
\definecolor{ds9blue}{HTML}{0066CC}
\definecolor{ds9red}{HTML}{CC0000}

% Additional packages for algorithms
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{multimedia}  % For pdfpc video playback
\graphicspath{{images/}}

% Title page configuration
\title[Sorting Algorithms]{C++ Sorting Algorithms}
\subtitle{Implementation and Visualization}
\author[Mr. Gullo]{Mr. Gullo}
\date[\today]{\today}

% Code listing style
\lstset{
  language=C++,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{ds9blue},
  stringstyle=\color{ds9red},
  commentstyle=\color{ds9grey},
  numbers=left,
  numberstyle=\tiny,
  frame=single,
  breaklines=true
}

\begin{document}

\frame{\titlepage}

\begin{frame}{Learning Objectives}
\begin{block}{After this presentation, you will:}
\begin{itemize}
\item Understand five different sorting algorithms
\item Be able to implement each sorting algorithm in C++
\item Know the advantages and disadvantages of each method
\item Recognize the time complexity of different algorithms
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Initial Array}
\begin{block}{Numbers to Sort}
Our example will use these 9 numbers: [7, 2, 9, 4, 5, 8, 3, 6, 10]
\end{block}
\end{frame}

\begin{frame}[fragile]{Bubble Sort}
\begin{block}{Algorithm Description}
\begin{itemize}
\item Repeatedly steps through the list
\item Compares adjacent elements and swaps them if needed
\item Continues until no swaps are needed
\end{itemize}
\end{block}

\begin{lstlisting}
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++)
        for (int j = 0; j < n-i-1; j++)
            if (arr[j] > arr[j+1])
                swap(arr[j], arr[j+1]);
}
\end{lstlisting}
\end{frame}

\begin{frame}{Bubble Sort Animation}
\begin{center}
% 300x180 = 5:3 aspect ratio
\movie[width=0.8\textwidth,height=0.48\textwidth,autostart,loop]{%
  \includegraphics[width=0.8\textwidth,height=0.48\textwidth,keepaspectratio]{bubble_sort_poster.png}%
}{../images/bubble_sort.mp4}
\end{center}
\begin{block}{Watch}
Adjacent elements swap until largest "bubbles" to the end.
\end{block}
\end{frame}

\begin{frame}{Bubble Sort Steps}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
7 & 2 & 9 & 4 & 5 & 8 & 3 & 6 & 10 \\
\hline
2 & 7 & 4 & 5 & 8 & 3 & 6 & 9 & 10 \\
\hline
2 & 4 & 5 & 7 & 3 & 6 & 8 & 9 & 10 \\
\hline
2 & 4 & 5 & 3 & 6 & 7 & 8 & 9 & 10 \\
\hline
2 & 4 & 3 & 5 & 6 & 7 & 8 & 9 & 10 \\
\hline
2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
\hline
\end{tabular}
\end{center}
\end{frame}

\begin{frame}[fragile]{Selection Sort}
\begin{block}{Algorithm Description}
\begin{itemize}
\item Divides array into sorted and unsorted regions
\item Finds minimum element in unsorted region
\item Swaps it with first element of unsorted region
\end{itemize}
\end{block}

\begin{lstlisting}
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        int min_idx = i;
        for (int j = i+1; j < n; j++)
            if (arr[j] < arr[min_idx])
                min_idx = j;
        swap(arr[min_idx], arr[i]);
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}{Selection Sort Animation}
\begin{center}
% 288x288 = 1:1 square
\movie[width=0.5\textwidth,height=0.5\textwidth,autostart,loop]{%
  \includegraphics[width=0.5\textwidth,height=0.5\textwidth,keepaspectratio]{selection_sort_poster.png}%
}{../images/selection_sort.mp4}
\end{center}
\begin{block}{Watch}
Find the minimum, swap to front. Repeat for remaining unsorted portion.
\end{block}
\end{frame}

\begin{frame}[fragile]{Insertion Sort}
\begin{block}{Algorithm Description}
\begin{itemize}
\item Builds sorted array one element at a time
\item Takes each element and inserts into correct position
\item Efficient for small or nearly sorted data
\end{itemize}
\end{block}

\begin{lstlisting}
void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}{Insertion Sort Animation}
\begin{center}
% 276x684 = ~2:5 tall portrait
\movie[width=0.25\textwidth,height=0.62\textwidth,autostart,loop]{%
  \includegraphics[width=0.25\textwidth,height=0.62\textwidth,keepaspectratio]{insertion_sort_poster.png}%
}{../images/insertion_sort.mp4}
\end{center}
\begin{block}{Watch}
Each element slides into its correct position in the sorted portion.
\end{block}
\end{frame}

\begin{frame}[fragile]{Merge Sort}
\begin{block}{Algorithm Description}
\begin{itemize}
\item Divide and conquer approach
\item Splits array in half recursively
\item Merges sorted halves back together
\end{itemize}
\end{block}
Time complexity: O(n log n) - consistent performance
\end{frame}

\begin{frame}{Merge Sort Animation}
\begin{center}
% 300x180 = 5:3 aspect ratio
\movie[width=0.8\textwidth,height=0.48\textwidth,autostart,loop]{%
  \includegraphics[width=0.8\textwidth,height=0.48\textwidth,keepaspectratio]{merge_sort_poster.png}%
}{../images/merge_sort.mp4}
\end{center}
\begin{block}{Watch}
Split, sort, merge. The "divide and conquer" strategy in action.
\end{block}
\end{frame}

\begin{frame}[fragile]{Quick Sort}
\begin{block}{Algorithm Description}
\begin{itemize}
\item Choose a pivot element
\item Partition: smaller elements left, larger elements right
\item Recursively sort the partitions
\end{itemize}
\end{block}
Time complexity: O(n log n) average, O(n²) worst case
\end{frame}

\begin{frame}{Quick Sort Animation}
\begin{center}
% 280x214 = ~4:3 aspect ratio
\movie[width=0.7\textwidth,height=0.535\textwidth,autostart,loop]{%
  \includegraphics[width=0.7\textwidth,height=0.535\textwidth,keepaspectratio]{quick_sort_poster.png}%
}{../images/quick_sort.mp4}
\end{center}
\begin{block}{Watch}
Pick pivot, partition, recurse. Generally the fastest in practice.
\end{block}
\end{frame}

% Continue with remaining frames similarly...

\begin{frame}{Time Complexity Comparison}
\begin{block}{Time Complexity}
\begin{itemize}
\item Bubble Sort: O(n²)
\item Selection Sort: O(n²)
\item Insertion Sort: O(n²)
\item Quick Sort: O(n log n) average, O(n²) worst case
\item Merge Sort: O(n log n)
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Summary}
\begin{block}{Key Points}
\begin{itemize}
\item Bubble Sort: Simple but inefficient
\item Selection Sort: Simple and performs well on small lists
\item Insertion Sort: Efficient for small data sets
\item Quick Sort: Generally the fastest in practice
\item Merge Sort: Consistent performance but requires extra space
\end{itemize}
\end{block}
\end{frame}

\end{document}
